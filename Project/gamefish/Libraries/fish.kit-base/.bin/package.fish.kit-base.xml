<?xml version="1.0"?>
<doc>
    <assembly>
        <name>package.fish.kit-base</name>
    </assembly>
    <members>
        <member name="T:GameFish.IOperate">
            <summary>
            Indicates something can be manually operated if a check passes. <br />
            For example: an <see cref="T:GameFish.Agent"/> telling their pawns to do stuff.
            </summary>
        </member>
        <member name="M:GameFish.IOperate.CanOperate">
            <summary>
            Is this allowed to call frame and/or fixed update operations? <br />
            This is a good place to put an ownership or input focus check.
            </summary>
        </member>
        <member name="M:GameFish.IOperate.FrameOperate(System.Single@)">
            <summary> Called during OnUpdate(if allowed). </summary>
        </member>
        <member name="M:GameFish.IOperate.FixedOperate(System.Single@)">
            <summary> Called during OnFixedUpdate(if allowed). </summary>
        </member>
        <member name="T:GameFish.ISkinned">
            <summary>
            Add this to stuff that uses a <see cref="T:Sandbox.SkinnedModelRenderer"/>.
            </summary>
        </member>
        <member name="T:GameFish.ITarget">
            <summary>
            Indicates that this is meant to target a <see cref="T:Sandbox.GameObject"/>(<see cref="P:GameFish.ITarget.Target"/>).
            </summary>
        </member>
        <member name="M:GameFish.ITransform.GetPosition">
            <returns> The transform's world position. </returns>
        </member>
        <member name="P:GameFish.ITransform.Center">
            <summary>
            The center of the object, such as its mass center or hull center. <br />
            Can be used to avoid calculating its bounds every time(expensive!).
            </summary>
        </member>
        <member name="M:GameFish.ITransform.SetPosition(Vector3@)">
            <summary> Sets position directly. Use <see cref="M:GameFish.ITransform.TrySetPosition(Vector3@)"/> to do so safely. </summary>
        </member>
        <member name="M:GameFish.ITransform.SetRotation(Rotation@)">
            <summary> Sets rotation directly. Use <see cref="M:GameFish.ITransform.TrySetRotation(Rotation@)"/> to do so safely. </summary>
        </member>
        <member name="M:GameFish.ITransform.SetScale(Vector3@)">
            <summary> Sets scale directly. Use <see cref="M:GameFish.ITransform.TrySetScale(Vector3@)"/> to do so safely. </summary>
        </member>
        <member name="M:GameFish.ITransform.TrySetPosition(Vector3@)">
            <summary>
            Safely sets the position.
            </summary>
            <returns> If the position wasn't a NaN or infinity. </returns>
        </member>
        <member name="M:GameFish.ITransform.TrySetRotation(Rotation@)">
            <summary>
            Safely sets the rotation.
            </summary>
            <returns> If the rotation wasn't a NaN or infinity. </returns>
        </member>
        <member name="M:GameFish.ITransform.TrySetScale(Vector3@)">
            <summary>
            Safely sets the scale.
            </summary>
            <returns> If the scale wasn't a NaN or infinity. </returns>
        </member>
        <member name="T:GameFish.IPhysics">
            <summary>
            Lets you access the Rigidbody and affect its forces.
            </summary>
        </member>
        <member name="T:GameFish.IRagdoll">
            <summary>
            Lets you access and affect something's ragdoll(assuming it has one).
            </summary>
        </member>
        <member name="M:GameFish.IRagdoll.EnableRagdoll(System.Boolean)">
            <param name="enableComponent"> Enable the <see cref="T:Sandbox.ModelPhysics"/> component. </param>
        </member>
        <member name="T:GameFish.IVelocity">
            <summary>
            Allows you to and manage forces easily on whatever.
            </summary>
        </member>
        <member name="P:GameFish.IVelocity.Velocity">
            <summary>
            The velocity this object current has, though <see cref="M:GameFish.IVelocity.GetVelocity"/> may give you a modified value.
            </summary>
        </member>
        <member name="M:GameFish.IVelocity.GetVelocity">
            <returns> Gets the velocity and its factors. </returns>
        </member>
        <member name="M:GameFish.IVelocity.SetVelocity(Vector3@)">
            <summary>
            Sets the velocity in a way that lets the object process it.
            </summary>
        </member>
        <member name="M:GameFish.IVelocity.TryModifyVelocity(Vector3@,Vector3@)">
            <summary>
            Tries to modify the velocity. Lets the object modify the result.
            </summary>
            <returns> If this object allows adding of the velocity. </returns>
        </member>
        <member name="M:GameFish.IVelocity.TryModifyVelocity(Vector3@)">
            <summary>
            Tries to modify the velocity. Lets the object modify the result.
            </summary>
            <returns> If this object allows adding of the velocity. </returns>
        </member>
        <member name="M:GameFish.IVelocity.ApplyVelocity(System.Single@)">
            <summary>
            Put your movement/physics code here.
            </summary>
        </member>
        <member name="T:GameFish.FollowingEffect">
            <summary>
            Allows an effect to follow something without being a child. <br />
            It is not destroyed along with the target, allowing the effect to finish playing. <br />
            Destroys the object it is on if the effect is done or wasn't configured properly.
            </summary>
        </member>
        <member name="P:GameFish.FollowingEffect.Following">
            <summary>
            The object meant to be followed.
            </summary>
        </member>
        <member name="P:GameFish.FollowingEffect.Offset">
            <summary>
            The local transform to keep as an offset from <see cref = "P:GameFish.FollowingEffect.Following"/>.
            </summary>
        </member>
        <member name="P:GameFish.FollowingEffect.EffectObject">
            <summary>
            The object of the effect we're making follow the target.
            </summary>
        </member>
        <member name="M:GameFish.FollowingEffect.Create``1(Sandbox.GameObject,Sandbox.GameObject,Transform,System.Nullable{System.Single})">
            <summary>
            Tries to make an effect follow something maturely.
            </summary>
            <returns> If the effect </returns>
        </member>
        <member name="M:GameFish.FollowingEffect.IsFinished">
            <returns> If the effect has finished playing. </returns>
        </member>
        <member name="T:GameFish.AmmoEquip">
            <summary>
            Has ammo and can reload.
            </summary>
        </member>
        <member name="T:GameFish.BaseEquip">
            <summary>
            An <see cref="T:GameFish.PawnEquipment"/> can store, deploy and use this.
            </summary>
        </member>
        <member name="P:GameFish.BaseEquip.ID">
            <summary> Identifies this class of equipment. </summary>
        </member>
        <member name="P:GameFish.BaseEquip.Name">
            <summary> The name of the equipment to display. </summary>
        </member>
        <member name="P:GameFish.BaseEquip.DefaultSlot">
            <summary>
            The slot this is goes in(if enforced).
            </summary>
        </member>
        <member name="M:GameFish.BaseEquip.AllowEquip(GameFish.BasePawn)">
            <returns> If a pawn can equip this. </returns>
        </member>
        <member name="M:GameFish.BaseEquip.OnPrimary">
            <summary>
            Executes the primary function of this equipment. <br />
            You should call <see cref="M:GameFish.BaseEquip.TryPrimary"/> to call this while respecting cooldowns.
            </summary>
        </member>
        <member name="M:GameFish.BaseEquip.OnSecondary">
            <summary>
            Executes the secondary function of this equipment. <br />
            You should call <see cref="M:GameFish.BaseEquip.TrySecondary"/> to call this while respecting cooldowns.
            </summary>
        </member>
        <member name="T:GameFish.EquipSlot">
            <summary>
            Fancy words representing numbers 1-10.
            </summary>
        </member>
        <member name="T:GameFish.EquipState">
            <summary>
            Indicates if an equipment is dropped, deployed, or holstered.
            </summary>
        </member>
        <member name="F:GameFish.EquipState.Dropped">
            <summary>
            Probably on the ground somewhere.
            </summary>
        </member>
        <member name="F:GameFish.EquipState.Deployed">
            <summary>
            Actively held in an <see cref="T:GameFish.BasePawn"/>'s hands.
            </summary>
        </member>
        <member name="F:GameFish.EquipState.Holstered">
            <summary>
            Kept in <see cref="P:GameFish.PawnEquipment.Equipped"/> but not visible.
            </summary>
        </member>
        <member name="T:GameFish.EquipLoadoutEntry">
            <summary>
            An equipment prefab and a slot(optional).
            </summary>
        </member>
        <member name="T:GameFish.PawnEquipment">
            <summary>
            Manages and optionally spawns equipment.
            </summary>
        </member>
        <member name="M:GameFish.PawnEquipment.Get(System.String)">
            <summary>
            Gets a held equip using its ID(if it's there).
            </summary>
            <returns> The first found equip(or null). </returns>
        </member>
        <member name="M:GameFish.PawnEquipment.GetAll(System.String)">
            <summary>
            Gets all held equipment with an ID(if any).
            </summary>
            <returns> All equipment(or empty, never null). </returns>
        </member>
        <member name="M:GameFish.PawnEquipment.Get``1">
            <summary>
            Gets an equip of a specific type(if it's there).
            </summary>
            <returns> The first found <typeparamref name="T"/>(or null). </returns>
        </member>
        <member name="M:GameFish.PawnEquipment.AnyInSlot(System.Nullable{System.Int32})">
            <summary>
            Gets all equipment stuck in a slot.
            </summary>
            <returns> All equipment in that slot(or empty, never null). </returns>
        </member>
        <member name="M:GameFish.PawnEquipment.GetInSlot(System.Nullable{System.Int32})">
            <summary>
            Gets all equipment stuck in a slot.
            </summary>
            <returns> All equipment in that slot(or empty, never null). </returns>
        </member>
        <member name="P:GameFish.PawnEquipment.StrictSlots">
            <summary> If true: only try to pick up weapons in their intended slot. </summary>
        </member>
        <member name="P:GameFish.PawnEquipment.UniqueEquips">
            <summary> If true: prevent picking up multiple instances of a weapon. </summary>
        </member>
        <member name="P:GameFish.PawnEquipment.SlotCapacity">
            <summary> How many weapons can fit in each individual slot? </summary>
        </member>
        <member name="P:GameFish.PawnEquipment.SlotCount">
            <summary> How many equipment slots are available overall? </summary>
        </member>
        <member name="P:GameFish.PawnEquipment.AutoGiveLoadout">
            <summary>
            Automatically give the loadout when this module first starts? <br />
            If not then you'll need to call <see cref="M:GameFish.PawnEquipment.GiveLoadout"/> yourself.
            </summary>
        </member>
        <member name="P:GameFish.PawnEquipment.Loadout">
            <summary> The weapons to spawn. </summary>
        </member>
        <member name="P:GameFish.PawnEquipment.ActiveEquip">
            <summary>
            The equipment actively deployed(if any).
            </summary>
        </member>
        <member name="T:GameFish.HitscanWeapon">
            <summary>
            ðŸš€ Shoots bullets.
            </summary>
        </member>
        <member name="T:GameFish.ProjectileWeapon">
            <summary>
            ðŸš€ Shoots projectiles.
            </summary>
        </member>
        <member name="P:GameFish.ProjectileWeapon.ProjectileStartDistance">
            <summary>
            The distance to spawn the projectile from the aiming origin.
            </summary>
        </member>
        <member name="P:GameFish.ProjectileWeapon.OverrideScale">
            <summary>
            Set the prefab's scale when it's spawned?
            </summary>
        </member>
        <member name="P:GameFish.ProjectileWeapon.Scale">
            <summary>
            What to override the spawned prefab's scale with.
            </summary>
        </member>
        <member name="T:GameFish.RotationAxis">
            <summary>
            The relevant poles.
            </summary>
        </member>
        <member name="F:GameFish.RotationAxis.Pitch">
            <summary>
            Up and down.
            </summary>
        </member>
        <member name="F:GameFish.RotationAxis.Yaw">
            <summary>
            Left and right.
            </summary>
        </member>
        <member name="F:GameFish.RotationAxis.Roll">
            <summary>
            Sideways.
            </summary>
        </member>
        <member name="T:GameFish.RotationRelation">
            <summary>
            Indicates what direction to move towards or rotate around.
            </summary>
        </member>
        <member name="F:GameFish.RotationRelation.Object">
            <summary>
            Rotate relative to the object's rotation.
            </summary>
        </member>
        <member name="F:GameFish.RotationRelation.Axis">
            <summary>
            Rotate relative to a specific axis.
            </summary>
        </member>
        <member name="F:GameFish.RotationRelation.Absolute">
            <summary>
            Rotate on the static world axis with an offset.
            </summary>
        </member>
        <member name="T:GameFish.TransformOperation">
            <summary>
            Indicates how to affect a transform.
            </summary>
        </member>
        <member name="F:GameFish.TransformOperation.None">
            <summary> No effect. </summary>
        </member>
        <member name="F:GameFish.TransformOperation.Modify">
            <summary> Offset. </summary>
        </member>
        <member name="F:GameFish.TransformOperation.Set">
            <summary> Override. </summary>
        </member>
        <member name="T:GameFish.Transformer">
            <summary>
            Moves and/or rotates the object.
            <code> func_rotating </code>
            </summary>
        </member>
        <member name="P:GameFish.Transformer.AutoFind">
            <summary>
            If true: always look for valid collision-related components on the target if they havn't been found yet. <br /> <br />
            Enable this if you expect the components to change somehow.
            </summary>
        </member>
        <member name="P:GameFish.Transformer.UseCollision">
            <summary>
            THIS SHIT BROKEN. REASON: ENGINE BULLSHIT <br /> <br />
            If true: let colliders.. collide. With stuff. Potentially. <br />
            If false: just set the target's transform directly with no consideration of collision.
            </summary>
        </member>
        <member name="P:GameFish.Transformer.UseVelocity">
            <summary>
            If true: velocity is applied instead of directly moving it.
            </summary>
        </member>
        <member name="P:GameFish.Transformer.UseRotateOrigin">
            <summary>
            If true: rotation will be as if <see cref="P:GameFish.Transformer.RotateOrigin"/> was at the center.
            </summary>
        </member>
        <member name="P:GameFish.Transformer.RotateOrigin">
            <summary>
            The object to be rotated around the position of this object. <br />
            If <see cref="P:GameFish.Transformer.UseRotateOrigin"/> is enabled then the offset is created OnStart.
            </summary>
        </member>
        <member name="P:GameFish.Transformer.RotationDelta">
            <summary> The resulting rotation of pitch/yaw/roll offsets. </summary>
        </member>
        <member name="M:GameFish.Transformer.AffectRotation(System.Single@)">
            <returns> Where the thing should be moved/rotated to. </returns>
        </member>
        <member name="T:GameFish.BaseActor">
            <summary>
            Something that supports physics and has an <see cref="T:GameFish.ActorModel"/>.
            </summary>
        </member>
        <member name="P:GameFish.BaseActor.Model">
            <summary>
            The model of the actor, which may be <see cref="T:GameFish.ActorSkinnedModel"/> or some other kind.
            </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.EyeSource">
            <summary> Where are the eyes of our character? </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.Height">
            <summary> How tall are we? </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.LookAtEnabled">
            <summary> Are we looking at something? Useful for stuff like cutscenes, where you want an NPC to stare at you. </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.LookAt">
            <summary> Which GameObject should we be looking at? </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.IkLeftHand">
            <summary> IK will try to place the limb where this GameObject is in the world. </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.IkRightHand">
            <inheritdoc cref="P:GameFish.ActorCitizenModel.IkLeftHand"/>
        </member>
        <member name="P:GameFish.ActorCitizenModel.IkLeftFoot">
            <inheritdoc cref="P:GameFish.ActorCitizenModel.IkLeftHand"/>
        </member>
        <member name="P:GameFish.ActorCitizenModel.IkRightFoot">
            <inheritdoc cref="P:GameFish.ActorCitizenModel.IkLeftHand"/>
        </member>
        <member name="P:GameFish.ActorCitizenModel.EyeWorldTransform">
            <summary> The transform of the eyes, in world space. This is worked out from EyeSource is it's set. </summary>
        </member>
        <member name="M:GameFish.ActorCitizenModel.WithLook(Vector3,System.Single,System.Single,System.Single)">
            <summary> Have the player look at this point in the world </summary>
        </member>
        <member name="M:GameFish.ActorCitizenModel.WithVelocity(Vector3)">
            <summary> Have the player animate moving with a set velocity (this doesn't move them! Your character controller is responsible for that) </summary>
        </member>
        <member name="M:GameFish.ActorCitizenModel.WithWishVelocity(Vector3)">
            <summary>
            Animates the wish for the character to move in a certain direction. For example, when in the air, your character will swing their arms in that direction.
            </summary>
            <param name="Velocity"></param>
        </member>
        <member name="P:GameFish.ActorCitizenModel.AimAngle">
            <summary>
            Where are we aiming?
            </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.AimEyesWeight">
            <summary> The weight of the aim angle, but specifically for the Citizen's eyes. </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.AimHeadWeight">
            <summary> The weight of the aim angle, but specifically for the Citizen's head. </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.AimBodyWeight">
            <summary> The weight of the aim angle, but specifically for the Citizen's body. </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.MoveRotationSpeed">
            <summary>
            How much the character is rotating in degrees per second, this controls feet shuffling.
            If rotating clockwise this should be positive, if rotating counter-clockwise this should be negative.
            </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.DuckLevel">
            <summary> The scale of being ducked (crouched) (0 - 1) </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.VoiceLevel">
            <summary> How loud are we talking? </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.IsSitting">
            <summary> Are we sitting down? </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.IsGrounded">
            <summary> Are we on the ground? </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.IsSwimming">
            <summary> Are we swimming? </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.IsClimbing">
            <summary> Are we climbing? </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.IsNoclipping">
            <summary> Are we noclipping? </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.IsWeaponLowered">
            <summary>
            Is the weapon lowered? By default, this'll happen when the character hasn't been shooting for a while.
            </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.HoldType">
            <summary> What kind of weapon are we holding? </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.Handedness">
            <summary>
            What's the handedness of our weapon? Left handed, right handed, or both hands? This is only supported by some holdtypes, like Pistol, HoldItem.
            </summary>
        </member>
        <member name="M:GameFish.ActorCitizenModel.TriggerJump">
            <summary> Triggers a jump animation. </summary>
        </member>
        <member name="M:GameFish.ActorCitizenModel.TriggerDeploy">
            <summary> Triggers a weapon deploy animation. </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.MoveStyle">
            <summary> We can force the model to walk or run, or let it decide based on the speed. </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.SpecialMove">
            <summary>
            We can force the model to have a specific movement state, instead of just running around.
            <see cref="F:GameFish.ActorCitizenModel.SpecialMoveStyle.LedgeGrab"/> is good for shimmying across a ledge.
            <see cref="F:GameFish.ActorCitizenModel.SpecialMoveStyle.Roll"/> is good for a platformer game where the character is rolling around continuously.
            <see cref="F:GameFish.ActorCitizenModel.SpecialMoveStyle.Slide"/> is good for a shooter game or a platformer where the character is sliding.
            </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.Sitting">
            <summary> How are we sitting down? </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.SittingOffsetHeight">
            <summary> How far up are we sitting down from the floor? </summary>
        </member>
        <member name="P:GameFish.ActorCitizenModel.SittingPose">
            <summary> From 0-1, how much are we actually sitting down. </summary>
        </member>
        <member name="T:GameFish.CitizenOutfitter">
            <summary>
            Puts <see cref="T:Sandbox.Clothing"/> on an <see cref="T:GameFish.ActorSkinnedModel"/>.
            </summary>
        </member>
        <member name="P:GameFish.CitizenOutfitter.UseAvatar">
            <summary>
            Send the owner's avatar when outfitting?
            </summary>
        </member>
        <member name="P:GameFish.CitizenOutfitter.EditorAvatar">
            <summary>
            Allow loading your avatar in the editor?
            This can be annoying with multiple developers causing frequent changes.
            </summary>
        </member>
        <member name="P:GameFish.CitizenOutfitter.PreventAvatarSlots">
            <summary>
            Prevent avatar clothing with these slots from being used.
            </summary>
        </member>
        <member name="P:GameFish.CitizenOutfitter.UseDefault">
            <summary>
            If true: overlays a default outfit. <br />
            Overrides any avatar outfitting. Ignores <see cref="P:GameFish.CitizenOutfitter.PreventAvatarSlots"/>.
            </summary>
        </member>
        <member name="P:GameFish.CitizenOutfitter.Override">
            <summary>
            Allows you to temporarily override the avatar and/or custom outfit. <br/>
            Useful if you wanted to change clothing or make them a skeleton or something.
            </summary>
        </member>
        <member name="M:GameFish.CitizenOutfitter.ForceUpdate">
            <summary>
            Immediately applies the current configuration.
            </summary>
        </member>
        <member name="M:GameFish.CitizenOutfitter.SetOverride(GameFish.CitizenOutfit@)">
            <summary>
            Allows you to temporarily override the avatar and/or custom outfit. <br />
            Useful if you wanted to change clothing or make them a skeleton or something.
            </summary>
        </member>
        <member name="M:GameFish.CitizenOutfitter.ResetOverrides">
            <summary>
            Clears all temporarily forced outfitting.
            </summary>
        </member>
        <member name="M:GameFish.CitizenOutfitter.SetAvatar">
            <summary>
            Sets the current outfit to the local user's avatar(if you own this).
            </summary>
            <returns> If you own this. </returns>
        </member>
        <member name="T:GameFish.BaseEntity">
            <summary>
            The most basic form of a physical object that can separately exist.
            </summary>
        </member>
        <member name="P:GameFish.BaseEntity.HasHealth">
            <summary>
            Does this entity have a valid <see cref="T:GameFish.HealthComponent"/>?
            </summary>
        </member>
        <member name="T:GameFish.PhysicsEntity">
            <summary>
            A <see cref="T:GameFish.BaseEntity"/> that can have a Rigidbody on/in it.
            </summary>
        </member>
        <member name="T:GameFish.BaseTrigger">
            <summary>
            A trigger volume with callbacks and no filters. <br />
            Capable of creating, updating and rendering its collision.
            </summary>
        </member>
        <member name="F:GameFish.BaseTrigger.ColliderType.Manual">
            <summary>
            Doesn't create any colliders. Lets you add your own.
            </summary>
        </member>
        <member name="F:GameFish.BaseTrigger.ColliderType.Box">
            <summary>
            Automatically creates and resizes a box collider.
            </summary>
        </member>
        <member name="F:GameFish.BaseTrigger.ColliderType.Sphere">
            <summary>
            Automatically creates a sphere collider.
            </summary>
        </member>
        <member name="P:GameFish.BaseTrigger.Collider">
            <summary>
            Allows automatically creating, updating and previewing a collider.
            </summary>
        </member>
        <member name="P:GameFish.BaseTrigger.DebugLogging">
            <summary>
            Print debug logs?
            </summary>
        </member>
        <member name="P:GameFish.BaseTrigger.DebugGizmos">
            <summary>
            Render gizmos in play mode?
            </summary>
        </member>
        <member name="P:GameFish.BaseTrigger.OnEnter">
            <summary> An object that passed filters just touched this. </summary>
        </member>
        <member name="P:GameFish.BaseTrigger.OnExit">
            <summary> An object that passed filters just exited this. </summary>
        </member>
        <member name="P:GameFish.BaseTrigger.OnFirstEnter">
            <summary> A passing object just entered this it was previously empty. </summary>
        </member>
        <member name="P:GameFish.BaseTrigger.OnEmptied">
            <summary> The last/only object occupying this trigger just exited. </summary>
        </member>
        <member name="P:GameFish.BaseTrigger.OnInsideUpdate">
            <summary> Called every update for each object within this trigger. </summary>
        </member>
        <member name="P:GameFish.BaseTrigger.OnInsideFixedUpdate">
            <summary> Called every update for each object within this trigger. </summary>
        </member>
        <member name="P:GameFish.BaseTrigger.Initialized">
            <summary>
            Has <see cref="M:GameFish.BaseTrigger.OnStart"/> been called yet?
            </summary>
        </member>
        <member name="P:GameFish.BaseTrigger.HasTriggered">
            <summary>
            Has this ever once been triggered before?
            </summary>
        </member>
        <member name="M:GameFish.BaseTrigger.TestFilters(Sandbox.GameObject)">
            <summary>
            Run filtering checks and optional debug logging.
            </summary>
        </member>
        <member name="M:GameFish.BaseTrigger.PassesFilters(Sandbox.GameObject)">
            <returns> If the object passes this trigger's filters(if any). </returns>
        </member>
        <member name="T:GameFish.FilterTrigger">
            <summary>
            A trigger volume with tag, type and custom function filters. <br />
            Capable of creating, updating and previewing its collision.
            </summary>
        </member>
        <member name="P:GameFish.FilterTrigger.FilterType">
            <summary>
            If true: include/exclude by type.
            </summary>
        </member>
        <member name="P:GameFish.FilterTrigger.RequireType">
            <summary>
            They must have this type of component on them.
            </summary>
        </member>
        <member name="P:GameFish.FilterTrigger.FindMode">
            <summary>
            How to look for the component.
            </summary>
        </member>
        <member name="P:GameFish.FilterTrigger.FilterTags">
            <summary>
            If true: include/exclude by tags.
            </summary>
        </member>
        <member name="P:GameFish.FilterTrigger.IncludeTags">
            <summary>
            An object with any of these tags are accepted.
            </summary>
        </member>
        <member name="P:GameFish.FilterTrigger.ExcludeTags">
            <summary>
            An object with any of these tags are always ignored. <br />
            They're excluded even if they have an <see cref="P:GameFish.FilterTrigger.IncludeTags"/> tag.
            </summary>
        </member>
        <member name="P:GameFish.FilterTrigger.FunctionFilter">
            <summary>
            An additional, final check you can do in ActionGraph.
            </summary>
        </member>
        <member name="M:GameFish.FilterTrigger.PassesFilters(Sandbox.GameObject)">
            <returns> If the object passes this trigger's tag filters(if any) and custom filter(if any). </returns>
        </member>
        <member name="M:GameFish.FilterTrigger.TypesPassFilters(Sandbox.GameObject)">
            <summary>
            Returns if this set of tags is allowed. <br />
            Defaults to true if <see cref="P:GameFish.FilterTrigger.FilterTags"/> is disabled.
            </summary>
        </member>
        <member name="M:GameFish.FilterTrigger.TagsPassFilters(Sandbox.ITagSet)">
            <summary>
            Returns if this set of tags is allowed. <br />
            Defaults to true if <see cref="P:GameFish.FilterTrigger.FilterTags"/> is disabled.
            </summary>
        </member>
        <member name="T:GameFish.LadderTrigger">
            <summary>
            A trigger with the "ladder" tag and appropriate default collider. <br />
            You need a player/actor controller of some kind to utilize this. <br />
            Capable of creating, updating and previewing its collision.
            <code> func_ladder </code>
            </summary>
        </member>
        <member name="T:GameFish.VelocityTrigger">
            <summary>
            A trigger that affects the velocity of objects. <br />
            Can push, spin and/or slow physics objects down. <br />
            Capable of creating, updating and previewing its collision.
            <code> trigger_push </code> <code> trigger_catapult </code>
            </summary>
        </member>
        <member name="F:GameFish.VelocityTrigger.VelocityMethod.None">
            <summary>
            No force of this type is applied.
            </summary>
        </member>
        <member name="F:GameFish.VelocityTrigger.VelocityMethod.Instantaneous">
            <summary>
            Applies all force instantly upon entering.
            </summary>
        </member>
        <member name="F:GameFish.VelocityTrigger.VelocityMethod.Continuous">
            <summary>
            Adds momentum consistently over time.
            </summary>
        </member>
        <member name="F:GameFish.VelocityTrigger.VelocityRelation.Absolute">
            <summary>
            Always pushes/spins in the exact direction you specify.
            </summary>
        </member>
        <member name="F:GameFish.VelocityTrigger.VelocityRelation.Trigger">
            <summary>
            The trigger's orientation offsets the force's direction.
            </summary>
        </member>
        <member name="F:GameFish.VelocityTrigger.VelocityRelation.Object">
            <summary>
            Applies force relative to where the object itself is facing.
            </summary>
        </member>
        <member name="F:GameFish.VelocityTrigger.VelocityNegation.None">
            <summary>
            Doesn't affect forces prior to applying any new force.
            </summary>
        </member>
        <member name="F:GameFish.VelocityTrigger.VelocityNegation.Total">
            <summary>
            Zeros all previous velocity regardless of direction.
            </summary>
        </member>
        <member name="F:GameFish.VelocityTrigger.VelocityNegation.Opposing">
            <summary>
            Negates all force in the direction opposite of the force being added.
            </summary>
        </member>
        <member name="P:GameFish.VelocityTrigger.LinearMethod">
            <summary>
            When/how linear velocity(momentum) should be added.
            </summary>
        </member>
        <member name="P:GameFish.VelocityTrigger.LinearRelation">
            <summary>
            What direction linear velocity(momentum) should be added towards.
            </summary>
        </member>
        <member name="P:GameFish.VelocityTrigger.LinearImpulseNegation">
            <summary>
            Allows you to (optionally) cancel out all/opposing momentum.
            </summary>
        </member>
        <member name="P:GameFish.VelocityTrigger.LinearVelocity">
            <summary>
            How much linear velocity(momentum) to add.
            </summary>
        </member>
        <member name="P:GameFish.VelocityTrigger.AngularMethod">
            <summary>
            When/how angular velocity(torque/rotation) should be added.
            </summary>
        </member>
        <member name="P:GameFish.VelocityTrigger.AngularRelation">
            <summary>
            What orientation angular velocity(torque/rotation) should be added around.
            </summary>
        </member>
        <member name="P:GameFish.VelocityTrigger.AngularVelocity">
            <summary>
            How much angular velocity(torque/rotation) to add.
            </summary>
        </member>
        <member name="P:GameFish.VelocityTrigger.Drag">
            <summary>
            If true: objects within this move/spin slower.
            </summary>
        </member>
        <member name="P:GameFish.VelocityTrigger.LinearDrag">
            <summary>
            Higher numbers slow down momentum more.
            </summary>
        </member>
        <member name="P:GameFish.VelocityTrigger.AngularDrag">
            <summary>
            Higher numbers slow down turning/spinning more.
            </summary>
        </member>
        <member name="M:GameFish.VelocityTrigger.SetVelocity(Sandbox.Rigidbody,Vector3@,Vector3@)">
            <summary>
            Directly modifies the velocity of <paramref name="rb"/>.
            </summary>
        </member>
        <member name="M:GameFish.VelocityTrigger.SetVelocity(Sandbox.GameObject,Vector3@,Vector3@)">
            <summary>
            Directly modifies velocities of the object's <see cref="T:Sandbox.Rigidbody"/>(if any).
            </summary>
        </member>
        <member name="T:GameFish.Client">
            <summary>
            An <see cref="T:GameFish.Agent"/> with an Identity that supports a connection.
            </summary>
        </member>
        <member name="P:GameFish.Client.Connected">
            <summary> Is the identity's connection defined and active? </summary>
        </member>
        <member name="M:GameFish.Client.AssignConnection(Sandbox.Connection,GameFish.Identity@)">
            <summary>
            Create a networkable ID for this client using a connection.
            </summary>
        </member>
        <member name="M:GameFish.Client.OnSetIdentity(GameFish.Identity@,GameFish.Identity@)">
            <summary>
            Allows you to modify and/or respond to new identity assignment.
            </summary>
        </member>
        <member name="M:GameFish.Client.SetName(System.String)">
            <summary>
            Updates the name of this client's identity(if valid).
            </summary>
        </member>
        <member name="F:GameFish.ClientType.Invalid">
            <summary>
            Not yet properly configured.
            </summary>
        </member>
        <member name="F:GameFish.ClientType.User">
            <summary>
            A real Client.
            </summary>
        </member>
        <member name="F:GameFish.ClientType.Bot">
            <summary>
            A fake Client.
            </summary>
        </member>
        <member name="T:GameFish.Identity">
            <summary>
            Networkable identifying client information for data/session persistence. <br />
            In other words: the key used to remember stuff about clients between sessions.
            </summary>
        </member>
        <member name="P:GameFish.Identity.IsValid">
            <returns> If the <see cref="P:GameFish.Identity.Type"/> was properly configured. </returns>
        </member>
        <member name="P:GameFish.Identity.Type">
            <summary>
            Is this client a player or a bot?
            </summary>
        </member>
        <member name="P:GameFish.Identity.Client">
            <summary>
            The component that owns this identity.
            </summary>
        </member>
        <member name="P:GameFish.Identity.Name">
            <summary>
            The last known display name of the client.
            </summary>
        </member>
        <member name="P:GameFish.Identity.Id">
            <summary>
            The identification key. <br />
            Probably from a user's connection.
            </summary>
        </member>
        <member name="P:GameFish.Identity.SteamId">
            <summary> Their Steam ID. Might be for a fake client. </summary>
        </member>
        <member name="P:GameFish.Identity.Address">
            <summary> The user's IP. Used to find this identity after rejoining. </summary>
        </member>
        <member name="P:GameFish.Identity.Connection">
            <summary>
            The current instance of a user's connection.
            </summary>
        </member>
        <member name="T:GameFish.Server">
            <summary>
            The networking manager.
            </summary>
        </member>
        <member name="P:GameFish.Server.Time">
            <summary>
            Time in seconds since the Unix epoch.
            </summary>
        </member>
        <member name="M:GameFish.Server.AssignClient(Sandbox.PrefabFile,Sandbox.Connection)">
            <summary>
            Finds an existing(or creates and registers a new) <see cref="T:GameFish.Client"/> object.
            </summary>
        </member>
        <member name="M:GameFish.Server.AssignClient``1(Sandbox.PrefabFile,Sandbox.Connection)">
            <summary>
            Finds an existing(or creates and registers a new) <typeparamref name="TClient"/> object.
            </summary>
        </member>
        <member name="M:GameFish.Server.RegisterIdentity(GameFish.Identity@)">
            <summary>
            Adds an <see cref="T:GameFish.Identity"/> to the history by its connection Id.
            </summary>
            <param name="id"></param>
        </member>
        <member name="T:GameFish.Agent">
            <summary>
            Something capable of control over other objects. <br />
            It may be a player(real/fake) or an NPC.
            </summary>
        </member>
        <member name="P:GameFish.Agent.IsPlayer">
            <summary>
            Is this meant to be owned by a player?
            </summary>
        </member>
        <member name="P:GameFish.Agent.Pawns">
            <summary>
            Which pawns are known to be under this agent's control?
            </summary>
        </member>
        <member name="P:GameFish.Agent.Connected">
            <summary>
            If NPC/Bot: always true. ('cause they in the matrix or some shit) <br />
            If <see cref="T:GameFish.Client"/>: if the connection exists and is active.
            </summary>
        </member>
        <member name="M:GameFish.Agent.CompareConnection(Sandbox.Connection)">
            <summary>
            If NPC/Bot: always false. <br />
            If Client: if our <see cref="P:GameFish.Agent.Identity"/> has the specified connection.
            </summary>
        </member>
        <member name="P:GameFish.Agent.Name">
            <summary>
            The display name of this guy/gal/whatever.
            </summary>
        </member>
        <member name="M:GameFish.Agent.GetSpawnPoint">
            <returns> A random default spawn point's transform(if any). </returns>
        </member>
        <member name="M:GameFish.Agent.SetPawn(Sandbox.PrefabFile,System.Boolean)">
            <summary>
            Spawns a <see cref="T:GameFish.BasePawn"/> prefab and assigns it to this agent.
            </summary>
            <param name="prefab"></param>
            <param name="dropAll"> Set this as the only owned pawn? </param>
        </member>
        <member name="M:GameFish.Agent.SetPawn``1(Sandbox.PrefabFile,System.Boolean)">
            <summary>
            Spawns a <typeparamref name="TPawn"/> prefab and assigns it to this agent.
            </summary>
            <param name="prefab"></param>
            <param name="dropAll"> Set this as the only owned pawn? </param>
        </member>
        <member name="M:GameFish.Agent.SetPawn``1(Sandbox.GameObject,System.Boolean,System.Boolean)">
            <summary>
            Assigns a pawn to this agent from an existing object.
            </summary>
            <param name="go"> The <see cref="T:Sandbox.GameObject"/> with <typeparamref name="TPawn"/> on it. </param>
            <param name="dropAll"> Set this as the only owned pawn? </param>
            <param name="failDestroy"> Destroy the object upon failure? </param>
        </member>
        <member name="M:GameFish.Agent.AddPawn(GameFish.BasePawn)">
            <summary>
            Called by the host to register a pawn assigned to this agent.
            </summary>
        </member>
        <member name="M:GameFish.Agent.OnLosePawn(GameFish.BasePawn)">
            <summary>
            Called after a pawn we owned was confirmed to be removed.
            </summary>
        </member>
        <member name="M:GameFish.Agent.OnGainPawn(GameFish.BasePawn)">
            <summary>
            Called after a pawn we didn't own is confirmed to be owned.
            </summary>
        </member>
        <member name="M:GameFish.Agent.ValidatePawns">
            <summary>
            Clears out references to invalid or unowned pawns.
            </summary>
        </member>
        <member name="M:GameFish.Agent.RequestTakePawn(GameFish.BasePawn)">
            <summary>
            Sends a request to the host to take a pawn.
            </summary>
        </member>
        <member name="M:GameFish.Agent.RpcTryTakePawnHostResponse(GameFish.BasePawn,GameFish.AttemptStatus)">
            <summary>
            This is the method you want to call so the host can tell the owner what happened.
            </summary>
        </member>
        <member name="M:GameFish.Agent.CanOperate">
            <returns> If this computer can tell these pawns what to do. </returns>
        </member>
        <member name="T:GameFish.BasePawn">
            <summary>
            Something an <see cref="T:GameFish.Agent"/> can control.
            </summary>
        </member>
        <member name="M:GameFish.BasePawn.GetAll``1">
            <returns> Every valid <typeparamref name="TPawn"/> regardless of enabled state. (expensive!) </returns>
        </member>
        <member name="M:GameFish.BasePawn.GetAllActive``1">
            <returns> Every valid and active <typeparamref name="TPawn"/>. (might be expensive) </returns>
        </member>
        <member name="M:GameFish.BasePawn.GetAllOwnedBy``1(GameFish.Agent,System.Boolean)">
            <returns> Every pawn owned by the <typeparamref name="TPawn"/>(or empty if null). </returns>
        </member>
        <member name="M:GameFish.BasePawn.AllowInput">
            <returns> If this pawn should listen to the local client's input. </returns>
        </member>
        <member name="P:GameFish.BasePawn.Agent">
            <summary>
            The agent controlling this pawn. Could be a player or NPC.
            </summary>
        </member>
        <member name="P:GameFish.BasePawn.Actor">
            <summary>
            The thing with the model that does the stuff.
            </summary>
        </member>
        <member name="M:GameFish.BasePawn.OnSetOwner(GameFish.Agent,GameFish.Agent)">
            <summary>
            Called when the <see cref="P:GameFish.BasePawn.Agent"/> property has been set to a new value.
            </summary>
        </member>
        <member name="M:GameFish.BasePawn.OnTaken(GameFish.Agent,GameFish.Agent)">
            <summary>
            Called when our new <see cref="P:GameFish.BasePawn.Agent"/> has been fully confirmed.
            </summary>
        </member>
        <member name="M:GameFish.BasePawn.OnDropped(GameFish.Agent)">
            <summary>
            Called whenever an <see cref="P:GameFish.BasePawn.Agent"/> stops owning this.
            </summary>
        </member>
        <member name="M:GameFish.BasePawn.AllowOwnership(GameFish.Agent)">
            <summary>
            Can an agent take ownership of this pawn?
            </summary>
            <returns> If ownership would be allowed. </returns>
        </member>
        <member name="T:GameFish.ControllerPawn">
            <summary>
            A simple pawn that uses the built-in <see cref="T:Sandbox.PlayerController"/>.
            </summary>
        </member>
        <member name="P:GameFish.ControllerPawn.Controller">
            <summary>
            A player-intended mobile extension of will.
            </summary>
        </member>
        <member name="T:GameFish.PlayerPawn">
            <summary>
            A player-only pawn that uses the <see cref="T:Sandbox.PlayerController"/>.
            </summary>
        </member>
        <member name="M:GameFish.PlayerPawn.AllowOwnership(GameFish.Agent)">
            <summary>
            Only player <see cref="T:GameFish.Agent"/>s can own a player pawn.
            </summary>
        </member>
        <member name="T:GameFish.DataFile`2">
            <summary>
            âš™ ðŸ›  ðŸ“‹ <br />
            A component for managing a specific file. <br />
            Can read/write any type of JSON-serializable data.
            </summary>
        </member>
        <member name="M:GameFish.DataFile`2.CreateData">
            <returns> A new instance of <typeparamref name="TDataClass"/>. </returns>
        </member>
        <member name="T:GameFish.DataFile`2.DataClass">
            <summary>
            The class meant to contain <typeparamref name="TDataComp"/>'s data. <br />
            Define its <typeparamref name="TDataClass"/> as a derivation of this.
            </summary>
        </member>
        <member name="P:GameFish.DataFile`2.IsDirty">
            <summary>
            If the file data has been modified in some way since saving.
            </summary>
        </member>
        <member name="P:GameFish.DataFile`2.AutoLoading">
            <summary>
            Load the file whenever this component is loaded?
            </summary>
        </member>
        <member name="P:GameFish.DataFile`2.AutoSaving">
            <summary>
            Automatically save upon a change after <see cref="P:GameFish.DataFile`2.AutoSaveDelay"/>?
            </summary>
        </member>
        <member name="P:GameFish.DataFile`2.AutoSaveDelay">
            <summary>
            If the file data has been modified in some way since saving.
            </summary>
        </member>
        <member name="P:GameFish.DataFile`2.Debug">
            <summary> Print debug logs? </summary>
        </member>
        <member name="M:GameFish.DataFile`2.ToString">
            <returns> The file's type and file path. </returns>
        </member>
        <member name="M:GameFish.DataFile`2.AutoSave(System.Boolean)">
            <summary>
            Auto-saves if data was modified, after a delay.
            </summary>
        </member>
        <member name="M:GameFish.Settings.Data.GetMixerVolumes">
            <returns> A table of existing mixers and their current volumes. </returns>
        </member>
        <member name="T:GameFish.HealthComponent">
            <summary>
            Takes damage and calls health-related events/hooks.
            Add this to the root of the prefab/object you want to have health.
            </summary>
        </member>
        <member name="P:GameFish.HealthComponent.Interface">
            <summary>
            This is what you use to call <see cref="M:GameFish.IHealth.TryDamage(Sandbox.DamageInfo)"/> and such.
            </summary>
        </member>
        <member name="P:GameFish.HealthComponent.IsDestructible">
            <summary> Is this capable of ever taking damage? </summary>
        </member>
        <member name="P:GameFish.IHealth.IsDestructible">
            <summary> Is this capable of ever taking damage? </summary>
        </member>
        <member name="P:GameFish.IHealth.HealthEvents">
            <summary>
            The collection of <see cref="T:GameFish.IHealthEvent"/>s relevant to this object. <br />
            Example: retrieved from a <see cref="T:Sandbox.ComponentList"/>.
            </summary>
        </member>
        <member name="T:GameFish.IModules`1">
            <summary>
            Allows a component to have modules.
            </summary>
        </member>
        <member name="P:GameFish.IModules`1.Component">
            <summary>
            The component we're adding modules to. <br />
            Implementation:
            <code> public (T) Component => this; </code>
            </summary>
        </member>
        <member name="P:GameFish.IModules`1.Modules">
            <summary>
            A way to access this interface. <br />
            Implementation:
            <code> public IModules(T) Modules => this; </code>
            </summary>
        </member>
        <member name="P:GameFish.IModules`1.ModuleList">
            <summary>
            The cached list of registered modules. <br />
            Use <see cref="M:GameFish.IModules`1.GetModules"/> to also auto-register them if necessary.
            </summary>
        </member>
        <member name="M:GameFish.IModules`1.HasModule``1">
            <summary>
            Quickly checks the cache to see if we have this module.
            </summary>
            <typeparam name="TMod"> The specific type module for <typeparamref name="T"/>. </typeparam>
            <returns> If the module exists. </returns>
        </member>
        <member name="M:GameFish.IModules`1.GetModules">
            <summary>
            Always gives you a cached list of modules. Registers them if that hasn't been done yet.
            </summary>
            <returns> The cached list of modules. </returns>
        </member>
        <member name="M:GameFish.IModules`1.GetModule``1">
            <typeparam name="TMod"> The specific type module for <typeparamref name="T"/>. </typeparam>
        </member>
        <member name="M:GameFish.IModules`1.GetModules``1">
            <typeparam name="TMod"> The specific type module for <typeparamref name="T"/>. </typeparam>
            <returns> Every module of this type(if any, never null). </returns>
        </member>
        <member name="M:GameFish.IModules`1.TryGetModule``1(``0@)">
            <typeparam name="TMod"> The specific type module for <typeparamref name="T"/>. </typeparam>
        </member>
        <member name="T:GameFish.Module`1">
            <summary>
            A module for <typeparamref name="T"/> components. Registers itself.
            </summary>
        </member>
        <member name="P:GameFish.Module`1.EditingScene">
            <summary>
            Is this component currently loaded in the scene editor? <br />
            Otherwise it is assumed to be in play mode. <br />
            You can use this with <see cref="T:HideIfAttribute"/> or <see cref="T:ShowIfAttribute"/>.
            </summary>
        </member>
        <member name="P:GameFish.Module`1.ParentComponent">
            <summary>
            The <typeparamref name="T"/> this module should register with.
            </summary>
        </member>
        <member name="M:GameFish.Module`1.OnRegistered(`0)">
            <summary>
            Called when this has been successfully registered onto a parent component.
            </summary>
        </member>
        <member name="M:GameFish.Module`1.OnRemoved(`0)">
            <summary>
            Called when this has been removed from a parent component.
            </summary>
        </member>
        <member name="T:GameFish.MusicFile">
            <summary>
            A sound file with a volume and support for start/end times.
            </summary>
        </member>
        <member name="P:GameFish.MusicFile.Volume">
            <summary>
            The default volume.
            </summary>
        </member>
        <member name="P:GameFish.MusicFile.HasAudibleRange">
            <summary>
            Indicates that the range was configured(hopefully correctly).
            </summary>
        </member>
        <member name="P:GameFish.MusicFile.AudibleRange">
            <summary>
            The start/end time in seconds when this is audible. <br />
            Used in cases where music needs to line up. <br />
            If the max is zero or less then the sound's duration is used.
            </summary>
        </member>
        <member name="P:GameFish.SoundSystem.DuckedVolume">
            <summary>
            Duckable sound sources will have their overall volume scaled by this amount.
            </summary>
        </member>
        <member name="M:GameFish.GameFish.Abs(System.Single)">
            <summary>
            <see cref="M:System.MathF.Abs(System.Single)"/>
            </summary>
        </member>
        <member name="M:GameFish.GameFish.Sign(System.Single)">
            <summary>
            <see cref="M:System.MathF.Sign(System.Single)"/>
            </summary>
        </member>
        <member name="M:GameFish.GameFish.InEditor(Sandbox.Component)">
            <returns> If this component is valid and loaded in an editor scene(not in game/play mode). </returns>
        </member>
        <member name="M:GameFish.GameFish.InGame(Sandbox.Component)">
            <returns> If this component is valid and loaded in a play mode scene(not scene/prefab editor). </returns>
        </member>
        <member name="M:GameFish.GameFish.Offset(Vector3,Vector3@)">
            <summary>
            B - A = Î” <br />
            Add this to <paramref name="from"/> to get <paramref name="to"/>.
            </summary>
        </member>
        <member name="M:GameFish.GameFish.Separate(Vector3,Vector3@,Vector3@,Vector3@)">
            <summary>
            Separate a vector into its forward/sideways components using the direction specified.
            </summary>
            <param name="v"></param>
            <param name="dir"> The forward-facing direction. </param>
            <param name="fwd"> Velocity pointing in that direction. </param>
            <param name="side"> Relative horizontal velocity. </param>
        </member>
        <member name="M:GameFish.GameFish.Forward(Vector3,Vector3@)">
            <summary>
            Gets the forward component of a vector using the specified direction. <br />
            Useful for velocity.
            </summary>
            <param name="v"></param>
            <param name="dir"> The forward-facing direction. </param>
            <returns> The forward component of the vector using the specified direction. </returns>
        </member>
        <member name="M:GameFish.GameFish.Sideways(Vector3,Vector3@)">
            <summary>
            Gets the sideways component of a vector using the specified direction. <br />
            Useful for velocity.
            </summary>
            <param name="v"></param>
            <param name="dir"> The sideways-facing direction. </param>
            <returns> The sideways component of the vector using the specified direction. </returns>
        </member>
        <member name="M:GameFish.GameFish.NetworkSetup(Sandbox.GameObject,Sandbox.Connection,Sandbox.NetworkOrphaned,Sandbox.OwnerTransfer,Sandbox.NetworkMode,System.Boolean)">
            <summary>
            Sets the object's network settings, network spawning if necessary and/or trying to set the owner.
            </summary>
            <param name="go"></param>
            <param name="cn"></param>
            <param name="orphanMode"></param>
            <param name="ownerTransfer"></param>
            <param name="netMode"></param>
            <param name="ignoreProxy"> Fails if the object is owned by another. </param>
            <returns> If the object was valid and we had permission. </returns>
        </member>
        <member name="M:GameFish.GameFish.IsOwner(Sandbox.GameObject)">
            <returns> If this object is explicitly owned by the local client. </returns>
        </member>
        <member name="M:GameFish.GameFish.IsOwner(Sandbox.Component)">
            <returns> If this component's object is explicitly owned by the local client. </returns>
        </member>
        <member name="M:GameFish.GizmoExtensions.DrawArrow(Sandbox.Component,Vector3,Vector3,Color,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{Transform})">
            <summary>
            Draws a slightly fancy arrow that better indicates depth.
            </summary>
            <param name="comp"> The component drawing this. </param>
            <param name="from"> The local origin of the arrow. </param>
            <param name="to"> The local end point of the arrow. </param>
            <param name="len"> The length of the arrow's head. </param>
            <param name="w"> The width of the arrow's head. </param>
            <param name="c"> The default color. </param>
            <param name="tWorld"> The world transform to use. Defaults to the component's world transform. </param>
            <returns> If the arrow could be drawn. </returns>
        </member>
        <member name="M:GameFish.GizmoExtensions.DrawBox(Sandbox.Component,BBox@,Color,System.Nullable{Transform})">
            <summary>
            Draws a slightly fancy box that better indicates depth.
            </summary>
            <param name="comp"> The component drawing this. </param>
            <param name="box"> The local bounds of the box. </param>
            <param name="c"> The default color. </param>
            <param name="tWorld"> The world transform to use. Defaults to the component's world transform. </param>
            <returns> If the box could be drawn. </returns>
        </member>
        <member name="M:GameFish.GizmoExtensions.DrawSphere(Sandbox.Component,System.Single@,Vector3@,Color,System.Nullable{Transform})">
            <summary>
            Draws a slightly fancy sphere that better indicates depth.
            </summary>
            <param name="comp"> The component drawing this. </param>
            <param name="radius"> The radius of the sphere. </param>
            <param name="center"> The offset of the sphere from world transform. </param>
            <param name="c"> The default color. </param>
            <param name="tWorld"> The world transform to use. Defaults to the component's world transform. </param>
            <returns> If the sphere could be drawn. </returns>
        </member>
        <member name="T:GameFish.AttemptStatus">
            <summary>
            The status of a process that expects a result.
            </summary>
        </member>
        <member name="F:GameFish.AttemptStatus.Active">
            <summary>
            The process is ongoing. A result has not been determined.
            </summary>
        </member>
        <member name="F:GameFish.AttemptStatus.Failure">
            <summary>
            The attempt has failed for some reason.
            </summary>
        </member>
        <member name="F:GameFish.AttemptStatus.Success">
            <summary>
            The attempt has succeeded.
            </summary>
        </member>
        <member name="T:GameFish.Random">
            <summary>
            Convenience methods for randomization. <br />
            Less typing means cleaner code. ðŸŽ²
            </summary>
        </member>
        <member name="P:GameFish.Random.CoinFlip">
            <returns> True or false. </returns>
        </member>
        <member name="M:GameFish.Random.Int(System.Int32)">
            <returns> Integer between 0 and <paramref name="max"/>. </returns>
        </member>
        <member name="M:GameFish.Random.Int(System.Int32,System.Int32)">
            <returns> Integer between <paramref name="a"/> and <paramref name="b"/>. </returns>
        </member>
        <member name="M:GameFish.Random.Float(System.Single)">
            <returns> Float between 0 and <paramref name="max"/>. </returns>
        </member>
        <member name="M:GameFish.Random.Float(System.Single,System.Single)">
            <returns> Float between <paramref name="a"/> and <paramref name="b"/>. </returns>
        </member>
        <member name="M:GameFish.Random.From``1">
            <returns> A random value from an enumeration. </returns>
        </member>
        <member name="M:GameFish.Prefab.Get(System.String)">
            <summary>
            Safely reference a prefab without breaking the entire project if it's missing.
            </summary>
        </member>
        <member name="M:GameFish.Prefab.GetFile(System.String)">
            <summary>
            Safely reference a <see cref="T:Sandbox.PrefabFile"/> without breaking the entire project if it's missing.
            </summary>
        </member>
        <member name="M:GameFish.Prefab.TrySpawn(Sandbox.PrefabFile,Sandbox.GameObject@)">
            <returns> If the prefab was valid and spawned a valid game object. </returns>
        </member>
        <member name="M:GameFish.Prefab.TrySpawn(Sandbox.PrefabFile,Transform,Sandbox.GameObject@)">
            <returns> If the prefab was valid and spawned a valid game object at the position. </returns>
        </member>
        <member name="M:GameFish.Prefab.TrySpawn(Sandbox.PrefabFile,Vector3,Sandbox.GameObject@)">
            <returns> If the prefab was valid and spawned a valid game object at the position. </returns>
        </member>
        <member name="T:GameFish.Singleton`1">
            <summary>
            A component you can access anywhere using its <see cref="P:GameFish.Singleton`1.Instance"/> property.
            </summary>
            <typeparam name="TComp"> The component you want to be a singleton. </typeparam>
        </member>
        <member name="P:GameFish.Singleton`1.Instance">
            <summary>
            The first active non-editor instance of <typeparamref name="TComp"/>.
            </summary>
        </member>
        <member name="P:GameFish.Singleton`1.EditorInstance">
            <summary>
            The first active instance of <typeparamref name="TComp"/>. <br />
            This works even in in the editor.
            </summary>
        </member>
        <member name="M:GameFish.SingletonExtensions.GetSingleton``1(``0,System.Boolean,System.Boolean)">
            <summary>
            Retrieves the first valid instance of a component in the scene and caches it. <br />
            Call this on the private static instance in your public property's getter to auto-assign it.
            </summary>
            <param name="instance"></param>
            <param name="isOwned"> If true: only consider network-owned components. </param>
            <param name="allowEditor"> If true: editor scenes can find/use singletons. </param>
            <returns> Null if in the editor or no instance was found. </returns>
        </member>
        <member name="T:GameFish.FloatRange">
            <summary>
            Min and max floats without a fixed value setting.
            </summary>
        </member>
        <member name="T:GameFish.Fraction">
            <summary>
            A <see cref="T:System.Single"/> that is always between 0 and 1.
            </summary>
        </member>
        <member name="T:GameFish.IntRange">
            <summary>
            Min and max integers without the fixed value setting.
            </summary>
        </member>
    </members>
</doc>
